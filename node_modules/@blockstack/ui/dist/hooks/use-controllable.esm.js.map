{"version":3,"file":"use-controllable.esm.js","sources":["../../src/hooks/use-controllable.ts"],"sourcesContent":["import { runIfFn, warn } from '../utils';\nimport * as React from 'react';\n\nexport function useControllableProp<T>(propValue: T | undefined, stateValue: T) {\n  const { current: isControlled } = React.useRef(propValue !== undefined);\n  const value = isControlled && typeof propValue !== 'undefined' ? propValue : stateValue;\n  return [isControlled, value] as const;\n}\n\nexport interface UseControllableStateProps<T> {\n  /**\n   * The value to used in controlled mode\n   */\n  value?: T;\n  /**\n   * The initial value to be used, in uncontrolled mode\n   */\n  defaultValue?: T | (() => T);\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?: (nextValue: T) => void;\n  /**\n   * The condition to update the state\n   */\n  shouldUpdate?: (prevState: T, state: T) => boolean;\n  /**\n   * The component name (for warnings)\n   */\n  name?: string;\n  /**\n   * A mapping for the props to give more contextual warning messages.\n   *\n   * In some components `value` might be called `index`, and defaultValue\n   * might be called `defaultIndex`, so this map helps us generate\n   * contextual warning messages\n   */\n  propsMap?: {\n    value?: string;\n    defaultValue?: string;\n    onChange?: string;\n  };\n}\n\nconst defaultPropsMap = {\n  value: 'value',\n  defaultValue: 'defaultValue',\n  onChange: 'onChange',\n};\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nexport function useControllableState<T>(props: UseControllableStateProps<T>) {\n  const {\n    value: valueProp,\n    defaultValue,\n    onChange,\n    shouldUpdate = () => true,\n    name = 'Component',\n    propsMap = defaultPropsMap,\n  } = props;\n\n  const [valueState, setValue] = React.useState(defaultValue as T);\n  const { current: isControlled } = React.useRef(valueProp !== undefined);\n\n  // don't switch from controlled to uncontrolled\n  React.useEffect(() => {\n    const nextIsControlled = valueProp !== undefined;\n\n    const nextMode = nextIsControlled ? 'a controlled' : 'an uncontrolled';\n    const mode = isControlled ? 'a controlled' : 'an uncontrolled';\n\n    warn({\n      condition: isControlled !== nextIsControlled,\n      message:\n        `Warning: ${name} is changing from ${mode} to ${nextMode} component. ` +\n        'Components should not switch from controlled to uncontrolled (or vice versa). ' +\n        `Use the '${propsMap['value']}' with an '${propsMap['onChange']}' handler. ` +\n        `If you want an uncontrolled component, remove the ${propsMap['value']} prop and use '${propsMap['defaultValue']}' instead. \"` +\n        'More info: https://fb.me/react-controlled-components',\n    });\n  }, [valueProp, isControlled, name]);\n\n  const { current: _defaultValue } = React.useRef(defaultValue);\n\n  React.useEffect(() => {\n    warn({\n      condition: _defaultValue !== defaultValue,\n      message:\n        `Warning: A component is changing the default value of an uncontrolled ${name} after being initialized. ` +\n        `To suppress this warning opt to use a controlled ${name}.`,\n    });\n  }, [JSON.stringify(defaultValue)]);\n\n  const value = isControlled ? (valueProp as T) : valueState;\n\n  const updateValue = React.useCallback(\n    (next: React.SetStateAction<T>) => {\n      const nextValue = runIfFn(next, value);\n      const shouldUpdateState = shouldUpdate(value, nextValue);\n\n      if (!shouldUpdateState) return;\n\n      if (!isControlled) {\n        setValue(next);\n      }\n\n      onChange?.(nextValue);\n    },\n    [onChange, shouldUpdate, isControlled, value]\n  );\n\n  return [value, updateValue] as [T, React.Dispatch<React.SetStateAction<T>>];\n}\n"],"names":["useControllableProp","propValue","stateValue","React","undefined","isControlled","current","value","defaultPropsMap","defaultValue","onChange","useControllableState","props","valueProp","shouldUpdate","name","propsMap","valueState","setValue","nextIsControlled","nextMode","mode","warn","condition","message","_defaultValue","JSON","stringify","updateValue","next","nextValue","runIfFn","shouldUpdateState"],"mappings":";;;SAGgBA,oBAAuBC,WAA0BC;sBAC7BC,MAAA,CAAaF,SAAS,KAAKG,SAA3B;MAAjBC,6BAATC;;AACR,MAAMC,KAAK,GAAGF,YAAY,IAAI,OAAOJ,SAAP,KAAqB,WAArC,GAAmDA,SAAnD,GAA+DC,UAA7E;AACA,SAAO,CAACG,YAAD,EAAeE,KAAf,CAAP;AACD;AAqCD,IAAMC,eAAe,GAAG;AACtBD,EAAAA,KAAK,EAAE,OADe;AAEtBE,EAAAA,YAAY,EAAE,cAFQ;AAGtBC,EAAAA,QAAQ,EAAE;AAHY,CAAxB;SAUgBC,qBAAwBC;MAE7BC,YAMLD,MANFL;MACAE,eAKEG,MALFH;MACAC,WAIEE,MAJFF;4BAIEE,MAHFE;MAAAA,gDAAe;AAAA,WAAM,IAAN;AAAA;oBAGbF,MAFFG;MAAAA,gCAAO;wBAELH,MADFI;MAAAA,wCAAWR;;wBAGkBL,QAAA,CAAeM,YAAf;MAAxBQ;MAAYC;;uBACef,MAAA,CAAaU,SAAS,KAAKT,SAA3B;MAAjBC,8BAATC;;AAGRH,EAAAA,SAAA,CAAgB;AACd,QAAMgB,gBAAgB,GAAGN,SAAS,KAAKT,SAAvC;AAEA,QAAMgB,QAAQ,GAAGD,gBAAgB,GAAG,cAAH,GAAoB,iBAArD;AACA,QAAME,IAAI,GAAGhB,YAAY,GAAG,cAAH,GAAoB,iBAA7C;AAEAiB,IAAAA,IAAI,CAAC;AACHC,MAAAA,SAAS,EAAElB,YAAY,KAAKc,gBADzB;AAEHK,MAAAA,OAAO,EACL,cAAYT,IAAZ,0BAAqCM,IAArC,YAAgDD,QAAhD,oBACA,gFADA,kBAEYJ,QAAQ,CAAC,OAAD,CAFpB,mBAE2CA,QAAQ,CAAC,UAAD,CAFnD,4EAGqDA,QAAQ,CAAC,OAAD,CAH7D,uBAGwFA,QAAQ,CAAC,cAAD,CAHhG,sBAIA;AAPC,KAAD,CAAJ;AASD,GAfD,EAeG,CAACH,SAAD,EAAYR,YAAZ,EAA0BU,IAA1B,CAfH;;uBAiBmCZ,MAAA,CAAaM,YAAb;MAAlBgB,+BAATnB;;AAERH,EAAAA,SAAA,CAAgB;AACdmB,IAAAA,IAAI,CAAC;AACHC,MAAAA,SAAS,EAAEE,aAAa,KAAKhB,YAD1B;AAEHe,MAAAA,OAAO,EACL,2EAAyET,IAAzE,yFACoDA,IADpD;AAHC,KAAD,CAAJ;AAMD,GAPD,EAOG,CAACW,IAAI,CAACC,SAAL,CAAelB,YAAf,CAAD,CAPH;AASA,MAAMF,KAAK,GAAGF,YAAY,GAAIQ,SAAJ,GAAsBI,UAAhD;AAEA,MAAMW,WAAW,GAAGzB,WAAA,CAClB,UAAC0B,IAAD;AACE,QAAMC,SAAS,GAAGC,OAAO,CAACF,IAAD,EAAOtB,KAAP,CAAzB;AACA,QAAMyB,iBAAiB,GAAGlB,YAAY,CAACP,KAAD,EAAQuB,SAAR,CAAtC;AAEA,QAAI,CAACE,iBAAL,EAAwB;;AAExB,QAAI,CAAC3B,YAAL,EAAmB;AACjBa,MAAAA,QAAQ,CAACW,IAAD,CAAR;AACD;;AAEDnB,IAAAA,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAGoB,SAAH,CAAR;AACD,GAZiB,EAalB,CAACpB,QAAD,EAAWI,YAAX,EAAyBT,YAAzB,EAAuCE,KAAvC,CAbkB,CAApB;AAgBA,SAAO,CAACA,KAAD,EAAQqB,WAAR,CAAP;AACD;;;;"}